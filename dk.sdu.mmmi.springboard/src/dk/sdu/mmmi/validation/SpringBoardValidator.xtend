/*
 * generated by Xtext 2.20.0
 */
package dk.sdu.mmmi.validation

import org.eclipse.xtext.validation.Check
import dk.sdu.mmmi.springBoard.CRUD
import java.util.regex.Pattern
import dk.sdu.mmmi.springBoard.Model
import dk.sdu.mmmi.springBoard.SpringBoardPackage
import dk.sdu.mmmi.springBoard.Identifier
import dk.sdu.mmmi.springBoard.ModelType
import dk.sdu.mmmi.springBoard.ListOf
import dk.sdu.mmmi.springBoard.Bool
import dk.sdu.mmmi.springBoard.Str
import dk.sdu.mmmi.springBoard.Gt
import dk.sdu.mmmi.springBoard.Lt
import dk.sdu.mmmi.springBoard.Lteq
import dk.sdu.mmmi.springBoard.Gteq
import dk.sdu.mmmi.springBoard.Comp
import dk.sdu.mmmi.springBoard.DetailService
import dk.sdu.mmmi.springBoard.SecurityConfig
import dk.sdu.mmmi.springBoard.Encoder
import dk.sdu.mmmi.springBoard.HTTP
import dk.sdu.mmmi.springBoard.Method
import dk.sdu.mmmi.springBoard.Local
import dk.sdu.mmmi.springBoard.Security
import dk.sdu.mmmi.springBoard.MultipleIPs
import dk.sdu.mmmi.springBoard.IPWhitelist
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.xbase.interpreter.Context
import org.eclipse.emf.ecore.EObject
import dk.sdu.mmmi.springBoard.LimitedIP

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SpringBoardValidator extends AbstractSpringBoardValidator {

	Pattern cPattern = Pattern.compile("([C]).*([C])")
	Pattern rPattern = Pattern.compile("([R]).*([R])")
	Pattern uPattern = Pattern.compile("([U]).*([U])")
	Pattern dPattern = Pattern.compile("([D]).*([D])")
	String ipRegex = ("([0-9]|[1-8][0-9]|9[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])")
	@Check
	def checkCrudActions(CRUD crud) {
		
		val matchString = crud.getAct().toString().replace(", ", "")

		val cMatcher = cPattern.matcher(matchString);
		
		if (cMatcher.find()) {
			error('Only one Create method allowed', crud, null);
		}
		
		val rMatcher = rPattern.matcher(matchString);
		
		if (rMatcher.find()) {
			error('Only one Read method allowed', crud, null);
		}
		
		val uMatcher = uPattern.matcher(matchString);
		
		if (uMatcher.find()) {
			error('Only one Update method allowed', crud , null);
		}
		
		val dMatcher = dPattern.matcher(matchString);
		
		if (dMatcher.find()) {
			error('Only one Delete method allowed', crud, null);
		}
		
	}
	
	/**
	 * Inspired by Bettini
	 */
	@Check
	def checkNoCycleInEntityHierarchy(Model model) {
		if (model.inh.base === null)
			return // nothing to check
		val visitedEntities = newHashSet(model)
		var current = model.inh.base
		while (current !== null) {
			if (visitedEntities.contains(current)) {
				error("Cycle in hierarchy of model '"+current.name+"'",
					SpringBoardPackage.Literals.MODEL__INH)
				return
			}
			visitedEntities.add(current)
			current = current.inh.base
		}
	}
	
	@Check
	def checkOnlySingleIdForModel(Model model) {
		if (model.inh !== null) {
			if (!model.fields.filter[ f | f.type instanceof Identifier].empty) {
				error("Subclasses must not have an ID field.", SpringBoardPackage.Literals.MODEL__FIELDS)
			}
		} else {
			if (model.fields.filter[ f | f.type instanceof Identifier].size != 1) {
				error("A model must have a single ID field.", SpringBoardPackage.Literals.MODEL__NAME)
			}
		}
	}
	
	@Check
	def checkComparisonOperator(Comp comp) {
		if (comp.left.type.class !== comp.right.type.class) {
			error("Type mismatch", comp, SpringBoardPackage.Literals.COMP__RIGHT)
		}
		switch comp.left.type {
			ModelType,
			ListOf,
			Bool,
			Str,
			Identifier: switch comp.op {
				Gt,
				Lt,
				Lteq,
				Gteq: error("Invalid operator for this type", comp, SpringBoardPackage.Literals.COMP__OP)
				default:''
			}
			default: ''
		}
	}
	
	@Check
	def checkDetailServiceRequirement(SecurityConfig config){
		if(config.optionalSettings.filter[option | option.detailService !== null].size !==1){
			error("A WebSecurityConfig needs a single Detailservice", SpringBoardPackage.Literals.SECURITY_CONFIG__OPTIONAL_SETTINGS)
		}	
	}
	
	@Check
	def checkEncoderRequirement(SecurityConfig config){
		if(config.optionalSettings.filter[option | option.encoder !== null].size !==1){
			error("A WebSecurityConfig needs a single Encoder", SpringBoardPackage.Literals.SECURITY_CONFIG__OPTIONAL_SETTINGS)
		}	
	}
	
	@Check
	def checkEncoderNaming(Encoder encoder){
			if(!encoder.name.toLowerCase.equals('bcrypt') &&
				!encoder.name.toLowerCase.equals("scrypt") &&
				!encoder.name.toLowerCase.equals("pbkdf2")){
					error("The currently supported encoders types are: 'BCrypt', 'SCrypt' and 'PBKDF2", SpringBoardPackage.Literals.ENCODER__NAME)
				}
	}
	
	@Check
	def checkHTTPNaming(HTTP http){
			if(!http.type.toLowerCase.equals('secure') &&
				!http.type.toLowerCase.equals("basic")){
					error("The currently supported http naming schemes are: 'secure' or 'basic", SpringBoardPackage.Literals.HTTP__TYPE)
				}
	}
	
	
	@Check
	def checkServiceModelBaseClassContainsUsernameAndPassword(DetailService config){		
			if(config.base.fields.filter[field | field.name.toLowerCase.equals("username")].empty ||
				(config.base.fields.filter[field | field.name.toLowerCase.equals("password")].empty)
			){
				error("A DetailService base model must have a username and password field", SpringBoardPackage.Literals.DETAIL_SERVICE__BASE)
			 }
		
	}
		
	@Check
	def checkLimitedIPisDefined(LimitedIP whitelistedElement){
	var security = EcoreUtil2.getContainerOfType(whitelistedElement.eContainer(), Security);
		for(whitelist : security.securities.filter(option | option.ipwhitelist !== null)){
			if(!whitelistedElement.ipAddress.equals(whitelist.ipwhitelist.ipAddresses.first) && !whitelist.ipwhitelist.ipAddresses.next.contains(whitelistedElement.ipAddress) ){
				error("You can only limit a previous defined IP (as part of a 'IPRANGE')", SpringBoardPackage.Literals.LIMITED_IP__IP_ADDRESS);	
			}
		}
	}

	@Check
	def checkIpRangeIsValidForIPS(MultipleIPs ip){
		for(String : ip.first.split('\\.')){
			if (!String.matches(ipRegex)) {
				error('Only octets between 0 and 255 are valid', SpringBoardPackage.Literals.MULTIPLE_IPS__FIRST);
			}
		}
		
		if (ip.first.split('\\.').length!==4){
			error("A valid IPv4 address consists of just four octets", SpringBoardPackage.Literals.MULTIPLE_IPS__FIRST)	
		}
		
		for(String : ip.next){
			for(ipaddress : String.split('\\.')){
				if (!ipaddress.matches(ipRegex)) {
					error('Only octets between 0 and 255 are valid', SpringBoardPackage.Literals.MULTIPLE_IPS__NEXT);
				}
				if (String.split('\\.').length!==4){
				error("A valid IPv4 address consists of just four octets", SpringBoardPackage.Literals.MULTIPLE_IPS__NEXT)	
				}
			}	
		}
		
	}
	
	
	@Check
	def checkApiPathNotAllowedForLocalMethods(Method method){
		if(method.req instanceof Local && method.apipath !== null){
			error("A custom endpoint can not be placed on a local method", SpringBoardPackage.Literals.METHOD__APIPATH)		
		}
		
	}
}
